{# useful macros -#}

{%- macro cls_name(cls) -%}
    {{ cls.name|replace('<', '_')|replace('>', '') }}
{%- endmacro -%}

{%- macro pointer(cls) -%}
    {%- if cls.rootclass == "Standard_Transient" or cls.name == "Standard_Transient" -%} ,opencascade::handle<{{cls.name}}>
    {%- elif cls.nonpublic_destructors|length>0 -%} ,std::unique_ptr<{{cls.name}}, py::nodelete>
    {%- else -%} ,std::unique_ptr<{{cls.name}}>
    {%- endif -%}
{%- endmacro -%}

{%- macro super(cls,classes) -%}
    {% if cls.superclass in class_dict %}, {{cls.superclass}} {% endif %}
{%- endmacro -%}


{%- macro argtypes(f) -%}
    {% for _,t in f.args %}{{ t }}{{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro argnames(f) -%}
    {% for arg,_ in f.args %} {{ "," if loop.first }} py::arg("{{arg}}"){{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro method_pointer(cls,f) -%}
    ({{f.return_type}} ({{cls.name}}::*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}::{{f.name}}
{%- endmacro -%}

{%- macro static_method_pointer(cls,f) -%}
    ({{f.return_type}} (*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}::{{f.name}}
{%- endmacro -%}

{%- macro function_pointer(f) -%}
    ({{f.return_type}} (*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}))  static_cast<{{f.return_type}} (*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %})>(&{{f.name}})
{%- endmacro -%}

{%- macro template_args_typename(t) -%}
    <{% for type,name in t.type_params %}{% if type %}{{ type }}{% else %}typename{% endif %} {{name}}{{ "," if not loop.last }}{% endfor %}>
{%- endmacro -%}

{%- macro template_args(t) -%}
    <{% for type,name in t.type_params %}{{name}}{{ "," if not loop.last }}{% endfor %}>
{%- endmacro -%}

{%- macro template_method_pointer(cls,f) -%}
    ({{f.return_type}} ({{cls.name}}{{template_args(cls)}}::*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}{{template_args(cls)}}::{{f.name}}
{%- endmacro -%}

{%- macro template_static_method_pointer(cls,f) -%}
    ({{f.return_type}} (*)({% for _,t in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}{{template_args(cls)}}::{{f.name}}
{%- endmacro -%}

{%- macro template_pointer(cls) -%}
    {%- if cls.rootclass == "Standard_Transient" or cls.name == "Standard_Transient" -%} ,opencascade::handle<{{cls.name}}{{template_args(cls)}}>
    {%- elif cls.nonpublic_destructors|length>0 -%} ,std::unique_ptr<{{cls.name}}{{template_args(cls)}}, py::nodelete>
    {%- else -%} ,std::unique_ptr<{{cls.name}}{{template_args(cls)}}>
    {%- endif -%}
{%- endmacro -%}

{# end of macros macros -#}

// pybind 11 related includes
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

// Standard Handle
#include <Standard_Handle.hxx>

// includes to resolve forward declarations
{% for h in module.headers %}{% for f in h.forwards %}{% if f.name in class_dict %}
#include <{{ class_dict[f.name].splitpath()[-1] }}>
{% endif %}{% endfor %}{% endfor %}

// module includes
{% for h in module.headers %}
#include <{{ h.short_name }}>
{% endfor %}

// user-defined pre
{% if include_pre %}
#include "{{ include_pre }}"
{% endif %}

// Module definiiton
void register_{{module.name}}(py::module &main_module) {

py::module m = main_module.def_submodule("{{module.name}}", R"#({{module.doc}})#");

// enums
{% for enum in module.enums %}
{% if enum.anonymous %}
    {% for val in enum.values %}
    m.attr("{{ val }}") = py::cast(int({{ val }}));
    {% endfor %}
{% else %}
    py::enum_<{{enum.name}}>(m, "{{enum.name}}",R"#({{enum.comment}})#")
    {% for val in enum.values %}
        .value("{{val}}",{{enum.name}}::{{val}}){{ ".export_values();" if loop.last }}
    {% endfor %}
{% endif %}
{% endfor %}

// classes
{% for c in module.classes %}{#% if not c.abstract %#}
    py::class_<{{c.name}} {{pointer(c)}} {{super(c,module.classes)}}>(m,"{{cls_name(c)}}",R"#({{c.comment}})#")
    {% for con in c.constructors %}
        .def(py::init< {{ argtypes(con) }} >() {{argnames(con)}} )
    {% endfor %}
    {% for m in c.methods %}
        .def("{{m.name}}",
             {{ method_pointer(c,m) }},
             R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for m in c.static_methods %}
        .def_static("{{m.name}}_s",
                    {{ static_method_pointer(c,m) }},
                    R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for op in c.operators %}
    {% if op.name in operator_dict %}
    {% for py_op in operator_dict[op.name] %}
        .def("{{py_op}}",
             {{ method_pointer(c,op) }},
             py::is_operator(),
             R"#({{op.comment}})#" {{argnames(op)}})
    {% endfor %}
    {% endif %}
    {% endfor %};
{#% endif %#}{% endfor %}

// functions
{% for h in module.headers %}
// {{h.name}}
{% for f in h.functions %}
    m.def("{{f.name}}", 
          {{ function_pointer(f) }},
          R"#({{ f.comment }})#" {{argnames(f)}});
{% endfor %}
{% endfor %}

// operators
{% for op in module.operators %}
{% if op.name in operator_dict %}
{% for py_op in operator_dict[op.name] %}
    m.def("{{py_op}}", 
          {{ function_pointer(op) }},
          py::is_operator(),
          R"#({{ op.comment }})#" {{argnames(op)}});
{% endfor %}
{% endif %}
{% endfor %}

// exceptions
{% for ex in module.exceptions %}
register_occ_exception<{{ex.name}}>(m, "{{ex.name}}");
{% endfor %}

}

// Class template handling functions
{% for h in module.headers %}
// {{h.name}}
{% for n,t in h.class_templates.items()%}

template {{template_args_typename(t)}}
void register_template_{{t.name}}(py::object m, const char *name){
    py::class_<{{t.name}}{{template_args(t)}} {{template_pointer(t)}} {{super(t,module.classes)}}>(m,name,R"#({{t.comment}})#")
    {% for con in t.constructors %}
        .def(py::init< {{ argtypes(con) }} >() {{argnames(con)}} )
    {% endfor %}
    {% for m in t.methods if not references_inner(m)%}
        .def("{{m.name}}",
             {{ template_method_pointer(t,m) }},
             R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for m in t.static_methods %}
        .def_static("{{m.name}}_s",
                    {{ template_static_method_pointer(t,m) }},
                    R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for op in t.operators %}
    {% if op.name in operator_dict %}
    {% for py_op in operator_dict[op.name] %}
        .def("{{py_op}}",
             {{ template_method_pointer(t,op) }},
             py::is_operator(),
             R"#({{op.comment}})#" {{argnames(op)}})
    {% endfor %}
    {% endif %}
    {% endfor %};
};
{% endfor %}
{% endfor %}

// user-defined post
{% if include_post %}
#include "{{ include_post }}"
{% endif %}