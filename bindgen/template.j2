{# useful macros -#}

{%- macro cls_name(cls) -%}
    {{ cls.name|replace('<', '_')|replace('>', '') }}
{%- endmacro -%}

{%- macro pointer(cls) -%}
    {%- if cls.superclass == "Standard_Transient" -%} ,opencascade::handle<{{cls.name}}>
    {%- elif cls.nonpublic_destructors|length>0 -%} ,std::unique_ptr<{{cls.name}}, py::nodelete>
    {%- else -%} ,std::unique_ptr<{{cls.name}}>
    {%- endif -%}
{%- endmacro -%}

{%- macro super(cls) -%}
    {% if cls.rootclass %}, {{cls.superclass}} {% endif %}
{%- endmacro -%}


{%- macro argtypes(f) -%}
    {% for arg in f.args %} {{ f.args[arg] }}{{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro argnames(f) -%}
    {% for arg in f.args %} {{ "," if loop.first }} py::arg("{{arg}}"){{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro method_pointer(cls,f) -%}
    ({{f.return_type}} ({{cls.name}}::*)({% for a in f.args %} {{f.args[a]}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}::{{f.name}}
{%- endmacro -%}

{%- macro static_method_pointer(cls,f) -%}
    ({{f.return_type}} (*)({% for a in f.args %} {{f.args[a]}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}::{{f.name}}
{%- endmacro -%}

{%- macro function_pointer(f) -%}
    ({{f.return_type}} (*)({% for a in f.args %} {{f.args[a]}} {{ "," if not loop.last }} {% endfor %}))  static_cast<{{f.return_type}} (*)({% for a in f.args %} {{f.args[a]}} {{ "," if not loop.last }} {% endfor %})>(&{{f.name}})
{%- endmacro -%}

{# end of macros macros -#}

// pybind 11 related includes
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

// Standard Handle
#include <Standard_Handle.hxx>

// includes to resolve forward declarations
{% for h in module.headers %}{% for f in h.forwards %}{% if f.name in class_dict %}
#include <{{ class_dict[f.name].splitpath()[-1] }}>
{% endif %}{% endfor %}{% endfor %}

// module includes
{% for h in module.headers %}
#include <{{ h.short_name }}>
{% endfor %}

// user-defined pre
{% if include_pre %}
#include "{{ include_pre }}"
{% endif %}

// Module definiiton
PYBIND11_MODULE({{module.name}}, m) {
    m.doc() = R"#({{module.doc}})#";
    
// dependencies
{% for dep in module.dependencies %}
    py::module::import("{{project_name}}::{{dep}}");
{% endfor %}

// enums
{% for enum in module.enums %}
{% if enum.anonymous %}
    {% for val in enum.values %}
    m.attr("{{ val }}") = py::cast(int({{ val }}));
    {% endfor %}
{% else %}
    py::enum_<{{enum.name}}>(m, "{{enum.name}}",R"#({{enum.comment}})#")
    {% for val in enum.values %}
        .value("{{val}}",{{enum.name}}::{{val}}){{ ".export_values();" if loop.last }}
    {% endfor %}
{% endif %}
{% endfor %}

// classes
{% for c in module.classes %}{% if not c.abstract %}
    py::class_<{{c.name}} {{pointer(c)}} {{super(c)}}>(m,"{{cls_name(c)}}",R"#({{c.comment}})#")
    {% for con in c.constructors %}
        .def(py::init< {{ argtypes(con) }} >() {{argnames(con)}} )
    {% endfor %}
    {% for m in c.methods %}
        .def("{{m.name}}",
             {{ method_pointer(c,m) }},
             R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for m in c.static_methods %}
        .def_static("{{m.name}}_s",
                    {{ static_method_pointer(c,m) }},
                    R"#({{m.comment}})#" {{argnames(m)}})
    {% endfor %}
    {% for op in c.operators %}
    {% if op.name in operator_dict %}
    {% for py_op in operator_dict[op.name] %}
        .def("{{py_op}}",
             {{ method_pointer(c,op) }},
             py::is_operator(),
             R"#({{op.comment}})#" {{argnames(op)}})
    {% endfor %}
    {% endif %}
    {% endfor %};
{% endif %}{% endfor %}

// functions
{% for h in module.headers %}
// {{h.name}}
{% for f in h.functions %}
    m.def("{{f.name}}", 
          {{ function_pointer(f) }},
          R"#({{ f.comment }})#" {{argnames(f)}});
{% endfor %}
{% endfor %}

// operators
{% for op in module.operators %}
{% if op.name in operator_dict %}
{% for py_op in operator_dict[op.name] %}
    m.def("{{py_op}}", 
          {{ function_pointer(op) }},
          py::is_operator(),
          R"#({{ op.comment }})#" {{argnames(op)}});
{% endfor %}
{% endif %}
{% endfor %}

}

// user-defined post
{% if include_post %}
#include "{{ include_post }}"
{% endif %}