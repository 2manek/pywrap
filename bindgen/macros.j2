{# useful macros -#}

{%- macro cls_name(cls) -%}
    {{ cls.name|replace('<', '_')|replace('>', '') }}
{%- endmacro -%}

{%- macro pointer(cls) -%}
    {%- if cls.rootclass == "Standard_Transient" or cls.name == "Standard_Transient" -%} ,opencascade::handle<{{cls.name}}>
    {%- elif cls.nonpublic_destructors|length>0 -%} ,std::unique_ptr<{{cls.name}}, py::nodelete>
    {%- else -%} ,std::unique_ptr<{{cls.name}}>
    {%- endif -%}
{%- endmacro -%}

{%- macro super(cls,classes) -%}
    {% if cls.superclass in classes %}, {{cls.superclass}} {% endif %}
{%- endmacro -%}

{%- macro prototype(f) -%}
    {{f.return_type}} {{f.name}}({% for n,t,d in f.args %}{{ t }} {{ n }}{{ "," if not loop.last }}{% endfor %}){% if f.const %} const {%endif%}
{%- endmacro -%}

{%- macro pybind_overload(c,m) -%}
    PYBIND11_OVERLOAD_PURE({{m.return_type}},{{c.name}},{{m.name}},{% for n,t,d in m.args %}{{ n }}{{ "," if not loop.last }}{% endfor %})
{%- endmacro -%}

{%- macro argtypes(f) -%}
    {% for _,t,_ in f.args %}{{ t }}{{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro argnames(f) -%}
    {% for arg,t,d in f.args %} {{ "," if loop.first }} py::arg("{{arg}}"){% if d %}=static_cast<{{t}}>({{d}}){% endif %}{{ "," if not loop.last }}{% endfor %}
{%- endmacro -%}

{%- macro method_pointer(cls,f) -%}
    ({{f.return_type}} ({{cls.name}}::*)({% for _,t,d in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) static_cast<{{f.return_type}} ({{cls.name}}::*)({% for _,t,_ in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}>(&{{cls.name}}::{{f.name}})
{%- endmacro -%}

{%- macro static_method_pointer(cls,f) -%}
    ({{f.return_type}} (*)({% for _,t,d in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) static_cast<{{f.return_type}} (*)({% for _,t,_ in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}>(&{{cls.name}}::{{f.name}})
{%- endmacro -%}

{%- macro function_pointer(f) -%}
    ({{f.return_type}} (*)({% for _,t,d in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}))  static_cast<{{f.return_type}} (*)({% for _,t,_ in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %})>(&{{f.name}})
{%- endmacro -%}

{%- macro template_args_typename(t) -%}
    <{% for type,name,default in t.type_params %}{% if type %}{{ type }}{% else %}typename{% endif %} {{name}}{% if default %}={{default}}{% endif %}{{ "," if not loop.last }}{% endfor %}>
{%- endmacro -%}

{%- macro template_args(t) -%}
    <{% for type,name,default in t.type_params %}{{name}}{{ "," if not loop.last }}{% endfor %}>
{%- endmacro -%}

{%- macro template_method_pointer(cls,f) -%}
    ({{f.return_type}} ({{cls.name}}{{template_args(cls)}}::*)({% for _,t,d in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}{{template_args(cls)}}::{{f.name}}
{%- endmacro -%}

{%- macro template_static_method_pointer(cls,f) -%}
    ({{f.return_type}} (*)({% for _,t,d in f.args %} {{t}} {{ "," if not loop.last }} {% endfor %}) {{ "const" if f.const }}) &{{cls.name}}{{template_args(cls)}}::{{f.name}}
{%- endmacro -%}

{%- macro template_pointer(cls) -%}
    {%- if cls.rootclass == "Standard_Transient" or cls.name == "Standard_Transient" -%} ,opencascade::handle<{{cls.name}}{{template_args(cls)}}>
    {%- elif cls.nonpublic_destructors|length>0 -%} ,std::unique_ptr<{{cls.name}}{{template_args(cls)}}, py::nodelete>
    {%- else -%} ,std::unique_ptr<{{cls.name}}{{template_args(cls)}}>
    {%- endif -%}
{%- endmacro -%}

{# end of macros macros -#}